---
title: 滚动数组
date: 2010-12-16 00:56:00 +0800
layout: post
published: true
comments: true
category: Acm
moveForm: baidu_qing
---
<div> <p>昨晚做了一道题，开了一个int [5000][5000]的数组，OLE了，虽然可以用short [5000][5000]猥琐过,但毕竟只是特殊情况</p><p>&nbsp;</p><p>正确的方法是滚动数组压缩存储，整理了一下网上的资料：</p><p>&nbsp;</p><p>利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。不过经常还是用在DP题目中，因为DP题目是一个自下而上的扩展过程，我们常常用到是连续的解，前面的解往往舍弃！所以用滚动数组可以说是很有必要的。</p><p>&nbsp;</p><p>滚动数组 举个简单的例子：</p><p>int i, d[100];</p><p>d[0] = 1;</p><p>d[1] = 1;</p><p>for (i = 2; i &lt; 100; i++)</p><p>&nbsp;&nbsp; &nbsp;d[i] = d[i - 1] + d[i - 2];</p><p>printf(&quot;%d&quot;, d[99]);</p><p>上面这个循环d[i]只依赖于前两个数据d[i - 1]和d[i - 2];</p><p>为了节约空间用滚动数组的做法</p><p>int d[3];</p><p>d[0] = 1;</p><p>d[1] = 1;</p><p>for (i = 2; i &lt; 100; i++)</p><p>&nbsp;&nbsp; &nbsp;d[i % 3] = d[(i - 1) % 3] + d[(i - 2) % 3];</p><p>printf(&quot;%d&quot;, d[99 % 3]);</p><p>注意上面的取余运算，我们成功地只保留了需要的最后3个解，数组好象在“</p><p>滚动”一样，所以叫滚动数组</p><p>&nbsp;</p><p>//DP</p><p>对于二维也可以用（代码可能不太正确和完善，但是可以理解例子）:</p><p>int i,j,d[100][100];</p><p>for(i=1;i&lt;100;i++)</p><p>&nbsp;&nbsp; &nbsp;for(j=0;j&lt;100;j++)</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;d[i][j]=d[i-1][j]+d[i][j-1];</p><p>&nbsp;</p><p>上面的d[i][j]只依赖于d[i-1][j],d[i][j-1];</p><p>运用滚动数组</p><p>int i,,j,d[2][100];</p><p>for(i=1;i&lt;100;i++)</p><p> &nbsp;&nbsp; &nbsp;for(j=0;j&lt;100;j++)</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;d[i%2][j]=d[(i-1)%2][j]+d[i%2][j-1];</p><p>&nbsp;</p><p>滚动数组实际是一种节省空间的办法，时间上没啥优势，多用于DP中，举个</p><p>&nbsp;</p><p>例子吧：&nbsp;</p><p>一个DP，平常如果需要1000×1000的空间，其实根据DP的无后效性，可以开成2×1000，然后通过滚动，获得和1000×1000一样的效果。滚动数组常用于DP之中，在DP过程中，我们在由一个状态转向另一个状态时，很可能之前存储的某些状态信息就已经无用了，例如在01背包问题中，从理解角度讲我们应开DP[i][j]的二维数组，第一维我们存处理到第几个物品，也就是阶段了，第二维存储容量，但是我们获得DP[i],只需使用DP[i - 1]的信息，DP[i - k],k&gt;1都成了无用空间，因此我们可以将数组开成一维就行，迭代更新数组中内容，滚动数组也是这个原理，目的也一样，不过这时候的问题常常是不可能缩成一维的了，比如一个DP[i][j]需要由DP[i - 1 ][k],DP[i - 2][k]决定，i&lt;n，0&lt;k&lt;=10;n &lt;= 100000000;显然缩不成一维,正常我们应该开一个DP[100000005][11]的数组，结果很明显，超内存，其实我们只要开DP[3][11]就够了DP[i%3][j]由DP[(i - 1)%3][k]和DP[(i - 2)%3][k]决定，空间复杂度差别巨大。</p><p></p> </div>
