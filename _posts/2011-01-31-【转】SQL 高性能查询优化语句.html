---
title: '【转】SQL 高性能查询优化语句'
date: 2011-01-31 00:33:00
layout: post
published: true
comments: true
moveForm: cnblogs
guid: http://www.cnblogs.com/un_estate/archive/2011/01/31/1948138.html
---

<p><span class="Apple" style="widows: 2; text-transform: none; text-indent: 0px; border-collapse: separate; font: medium Simsun; white-space: normal; orphans: 2; letter-spacing: normal; color: #000000; word-spacing: 0px;"><span class="Apple" style="text-align: left; line-height: 29px; font-family: Helvetica, Arial, sans-serif; color: #444444; font-size: 14px;">
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">保证在实现功能的基础上，尽量减少对<span style="margin: 0px; word-wrap: break-word; word-break: break-all; text-decoration: underline; padding: 0px;"><strong style="font-style: normal; margin: 0px; word-wrap: break-word; word-break: break-all; font-weight: bold; padding: 0px;">数据库</strong></span>的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如 SELECT * FROM T1语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM T1；在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />在没有建索引的情况下，数据库查找某一条数据，就必须进行全表扫描了，对所有数据进行一次遍历，查找出符合条件的记录。在数据量比较小的情况下，也许看不出明显的差别，但是当数据量大的情况下，这种情况就是极为糟糕的了。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SQL语句在SQL<span class="Apple">&nbsp;</span><span style="margin: 0px; word-wrap: break-word; word-break: break-all; text-decoration: underline; padding: 0px;"><strong style="font-style: normal; margin: 0px; word-wrap: break-word; word-break: break-all; font-weight: bold; padding: 0px;">SERVER</strong></span>中是如何执行的，他们担心自己所写的SQL语句会被SQL SERVER误解。比如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select * from table1 where name=&rsquo;zhangsan&rsquo; and tID &gt; 10000<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />和执行:<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select * from table1 where tID &gt; 10000 and name=&rsquo;zhangsan&rsquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />一些人不<span style="margin: 0px; word-wrap: break-word; word-break: break-all; text-decoration: underline; padding: 0px;"><strong style="font-style: normal; margin: 0px; word-wrap: break-word; word-break: break-all; font-weight: bold; padding: 0px;">知道</strong></span>以上两条语句的执行效率是否一样，因为如果简单的从语句先后上看，这两个语句的确是不一样，如果tID是一个聚合索引，那么后一句仅仅从表的 10000条以后的记录中查找就行了；而前一句则要先从全表中查找看有几个name=&rsquo;zhangsan&rsquo;的，而后再根据限制条件条件tID&gt; 10000来提出查询结果。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />事实上，这样的担心是不必要的。SQL SERVER中有一个&ldquo;查询分析优化器&rdquo;，它可以计算出where子句中的搜索条件并确定哪个索引能缩小表扫描的搜索空间，也就是说，它能实现自动优化。虽然查询优化器可以根据where子句自动的进行查询优化，但有时查询优化器就会不按照您的本意进行快速查询。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />在查询分析阶段，查询优化器查看查询的每个阶段并决定限制需要扫描的数据量是否有用。如果一个阶段可以被用作一个扫描参数（SARG），那么就称之为可优化的，并且可以利用索引快速获得所需数据。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SARG的定义：用于限制搜索的一个操作，因为它通常是指一个特定的匹配，一个值的范围内的匹配或者两个以上条件的AND连接。形式如下：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />列名 操作符 &lt;常数 或 变量&gt; 或 &lt;常数 或 变量&gt; 操作符 列名<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />列名可以出现在操作符的一边，而常数或变量出现在操作符的另一边。如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />Name=&rsquo;张三&rsquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />价格&gt;5000<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />5000&lt;价格<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />Name=&rsquo;张三&rsquo; and 价格&gt;5000<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />如果一个表达式不能满足SARG的形式，那它就无法限制搜索的范围了，也就是SQL SERVER必须对每一行都判断它是否满足WHERE子句中的所有条件。所以一个索引对于不满足SARG形式的表达式来说是无用的。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />所以，优化查询最重要的就是，尽量使语句符合查询优化器的规则避免全表扫描而使用索引查询。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">具体要注意的：</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">1.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num is null<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num=0</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">2.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">3.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num=10 or num=20<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />可以这样查询：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num=10<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />union all<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num=20</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">4.in 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num in(1,2,3)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />对于连续的数值，能用 between 就不要用 in 了：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num between 1 and 3</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">5.尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />见如下例子：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM T1 WHERE NAME LIKE &lsquo;%L%&rsquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=&rsquo;L&rsquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM T1 WHERE NAME LIKE &lsquo;L%&rsquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">6.必要时强制查询优化器使用某个索引，如在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where num=@num<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />可以改为强制查询使用索引：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t with(index(索引名)) where num=@num</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM T1 WHERE F1/2=100<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />应改为:<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM T1 WHERE F1=100*2</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=&rsquo;5378&rsquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />应改为:<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM RECORD WHERE CARD_NO LIKE &lsquo;5378%&rsquo;</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">SELECT member_number, first_name, last_name FROM members<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE DATEDIFF(yy,datofbirth,GETDATE()) &gt; 21<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />应改为:<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT member_number, first_name, last_name FROM members<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE dateofbirth &lt; DATEADD(yy,-21,GETDATE())<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where substring(name,1,3)='abc'--name以abc开头的id<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where datediff(day,createdate,'2005-11-30')=0--&lsquo;2005-11-30&rsquo;生成的id<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />应改为:<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where name like 'abc%'<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select id from t where createdate&gt;=&rsquo;2005-11-30&prime; and createdate&lt;'2005-12-1'</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">9.不要在 where 子句中的&ldquo;=&rdquo;左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">11.很多时候用 exists是一个好的选择：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />elect num from a where num in(select num from b)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />用下面的语句替换：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />select num from a where exists(select 1 from b where num=a.num)</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">SELECT SUM(T1.C1)FROM T1 WHERE(<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />(SELECT COUNT(*)FROM T2 WHERE T2.C2=T1.C2&gt;0)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT SUM(T1.C1) FROM T1WHERE EXISTS(<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT * FROM T2 WHERE T2.C2=T1.C2)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">如果你想校验表里是否存在某条纪录，不要用count(*)那样效率很低，而且浪费服务器资源。可以用EXISTS代替。如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />IF (SELECT COUNT(*) FROM table_name WHERE column_name = &lsquo;xxx&rsquo;)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />可以写成：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />IF EXISTS (SELECT * FROM table_name WHERE column_name = &lsquo;xxx&rsquo;)</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父结果集中有而在子结果集中没有的记录，如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT a.hdr_key FROM hdr_tbl a&mdash;- tbl a 表示tbl用别名a代替<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE NOT EXISTS (SELECT * FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT a.hdr_key FROM hdr_tbl a<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULL<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT hdr_key FROM hdr_tbl<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl)<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />三种写法都可以得到同样正确的结果，但是效率依次降低。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">12.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">13.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">14.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">15.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">16.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">17.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">18.尽量避免大事务操作，提高系统并发能力。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">19.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">20. 避免使用不兼容的数据类型。例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如:<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT name FROM employee WHERE salary &gt; 60000<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">21.充分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />例：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />第二句将比第一句执行快得多。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">22、使用视图加速查询<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序 操作，而且在其他方面还能简化优化器的工作。例如：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT cust.name，rcvbles.balance，&hellip;&hellip;other columns<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />FROM cust，rcvbles<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE cust.customer_id = rcvlbes.customer_id<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />AND rcvblls.balance&gt;0<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />AND cust.postcode&gt;&ldquo;98000&rdquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />ORDER BY cust.name</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个视图中，并按客户的名字进行排序：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />CREATE VIEW DBO.V_CUST_RCVLBES<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />AS<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT cust.name，rcvbles.balance，&hellip;&hellip;other columns<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />FROM cust，rcvbles<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE cust.customer_id = rcvlbes.customer_id<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />AND rcvblls.balance&gt;0<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />ORDER BY cust.name<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />然后以下面的方式在视图中查询：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT ＊ FROM V_CUST_RCVLBES<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />WHERE postcode&gt;&ldquo;98000&rdquo;<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />视图中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘I/O，所以查询工作量可以得到大幅减少。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">23、能用DISTINCT的就不用GROUP BY<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />可改为：<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">24.能用UNION ALL就不要用UNION<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">35.尽量不要用SELECT INTO语句。<br style="margin: 0px; word-wrap: break-word; word-break: break-all; padding: 0px;" />SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。</p>
<p style="padding-bottom: 10px; text-indent: 2em; margin: 0px 0px 6px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; word-break: break-all; padding-top: 0px;">上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体上看询成本百分比即可。</p>
</span></span></p>