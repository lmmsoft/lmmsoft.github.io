---
title: 题目：求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch
date: 2010-12-04 14:43:00 +0800
layout: post
published: true
comments: true
category: acm比赛
moveForm: baidu_qing
---
<div> <p> </p><p>题目：求1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C）。</p><p>分析：这道题没有多少实际意义，因为在软件开发中不会有这么变态的限制。但这道题却能有效地考查发散思维能力，而发散思维能力能反映出对编程相关技术理解的深刻程度。</p><p>通常求1+2+…+n除了用公式n(n+1)/2之外，无外乎循环和递归两种思路。由于已经明确限制for和while的使用，循环已经不能再用了。同样，递归函数也需要用if语句或者条件判断语句来判断是继续递归下去还是终止递归，但现在题目已经不允许使用这两种语句了。</p><p>我们仍然围绕循环做文章。循环只是让相同的代码执行n遍而已，我们完全可以不用for和while达到这个效果。比如定义一个类，我们new一含有n个这种类型元素的数组，那么该类的构造函数将确定会被调用n次。我们可以将需要执行的代码放到构造函数里。如下代码正是基于这个思路：</p><p>class Temp<br />{<br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Temp() { ++ N; Sum += N; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void Reset() { N = 0; Sum = 0; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static int GetSum() { return Sum; }<br /><br />private:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static int N;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static int Sum;<br />};<br /><br />int Temp::N = 0;<br />int Temp::Sum = 0;<br /><br />int solution1_Sum(int n)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Temp::Reset();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Temp *a = new Temp[n];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete []a;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = 0;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Temp::GetSum();<br />}</p><p>我们同样也可以围绕递归做文章。既然不能判断是不是应该终止递归，我们不妨定义两个函数。一个函数充当递归函数的角色，另一个函数处理终止递归的情况，我们需要做的就是在两个函数里二选一。从二选一我们很自然的想到布尔变量，比如ture（1）的时候调用第一个函数，false（0）的时候调用第二个函数。那现在的问题是如和把数值变量n转换成布尔值。如果对n连续做两次反运算，即!!n，那么非零的n转换为true，0转换为false。有了上述分析，我们再来看下面的代码：</p><p>class A;<br />A* Array[2];<br /><br />class A<br />{<br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual int Sum (int n) { return 0; }<br />};<br /><br />class B: public A<br />{<br />public:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual int Sum (int n) { return Array[!!n]-&gt;Sum(n-1)+n; }<br />};<br /><br />int solution2_Sum(int n)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A a;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B b;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array[0] = &amp;a;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array[1] = &amp;b;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int value = Array[1]-&gt;Sum(n);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;<br />}</p><p>这种方法是用虚函数来实现函数的选择。当n不为零时，执行函数B::Sum；当n为0时，执行A::Sum。我们也可以直接用函数指针数组，这样可能还更直接一些：</p><p>typedef int (*fun)(int);<br /><br />int solution3_f1(int i) <br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br />}<br /><br />int solution3_f2(int i)<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun f[2]={solution3_f1, solution3_f2}; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i+f[!!i](i-1);<br />}</p><p>另外我们还可以让编译器帮我们来完成类似于递归的运算，比如如下代码： </p><p>template &lt;int n&gt; struct solution4_Sum<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum Value { N = solution4_Sum&lt;n - 1&gt;::N + n};<br />};</p><p> </p><p>template &lt;&gt; struct solution4_Sum&lt;1&gt;<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum Value { N = 1};<br />};</p><p>solution4_Sum&lt;100&gt;::N就是1+2+...+100的结果。当编译器看到solution4_Sum&lt;100&gt;时，就是为模板类solution4_Sum以参数100生成该类型的代码。但以100为参数的类型需要得到以99为参数的类型，因为solution4_Sum&lt;100&gt;::N=solution4_Sum&lt;99&gt;::N+100。这个过程会递归一直到参数为1的类型，由于该类型已经显式定义，编译器无需生成，递归编译到此结束。由于这个过程是在编译过程中完成的，因此要求输入n必须是在编译期间就能确定，不能动态输入。这是该方法最大的缺点。而且编译器对递归编译代码的递归深度是有限制的，也就是要求n不能太大。</p><p>大家还有更多、更巧妙的思路吗？欢迎讨论^_^</p><p>博主何海涛对本博客文章享有版权。网络转载请注明出处<a href="http://zhedahht.blog.163.com/"  >http://zhedahht.blog.163.com/</a>。整理出版物请和作者联系。</p><p> </p><p>最后附上一个简单的代码：</p><p></p><p>#include &lt;iostream&gt;</p><p>int add(int n, int &amp;sum)</p><p>{</p><p> &nbsp;&nbsp;  n &amp;&amp; add(n-1, sum);</p><p> &nbsp;&nbsp;  return sum += n;</p><p>}<br /><br />int main()</p><p>{</p><p> &nbsp;&nbsp;  int sum = 0;</p><p>&nbsp;&nbsp;  int n = 100;</p><p>&nbsp;&nbsp;  std::cout &lt;&lt; add(n, sum) &lt;&lt; std::endl;return 0;</p><p>}</p><p> </p> </div>
