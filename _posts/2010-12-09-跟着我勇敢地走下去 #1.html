---
title: 跟着我勇敢地走下去 #1
date: 2010-12-09 14:53:30 +0800
layout: post
published: true
comments: true
category: acm比赛
moveForm: blog.163.com
---
<br><span style="font-family: Simsun; line-height: normal; font-size: medium; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;"><p>a<br>转化为Ax+By=N是否存在整数解的问题之后，观察到题目数据范围很小，所以可以采用枚举的方式计算。<br>(N-Ax)%B必然是一个随着x的改变存在循环节的函数，所以我们只需从0到B枚举x的值，如果其中存在(N-Ax)%B==0则有解，反之则无解。<br>PS：当AB比较大时做法是求出AB的最大公约数，之后判断N模它是否为零。</p><p>直接枚举：<br>#include &lt;stdio.h&gt;</p><p>int a,b,n,i;<br>bool pd;</p><p>int main()<br>{<br>&nbsp;&nbsp;&nbsp; while (scanf("%d%d%d",&amp;a,&amp;b,&amp;n)&amp;&amp;(a||b||n)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd=false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=-b;i&lt;0;i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((n-i*a)%b==0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pd=true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pd) printf("YES\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else printf("NO\n");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return a;<br>}</p><p>最大公约数：<br>#include &lt;stdio.h&gt;<br>int gcd(int x, int y)<br>{<br>&nbsp;&nbsp;&nbsp; if (y == 0){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return gcd(y, x % y);<br>}<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; int a, b, n;<br>&nbsp;&nbsp;&nbsp; while (scanf("%d%d", &amp;a, &amp;b) &amp;&amp; a + b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a &gt; b){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = a;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a = b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d", &amp;n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n % gcd(a, b)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("NO\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("YES\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br>&nbsp;</p><p><br>b<br>首先，我们知道，一个变量不一定全由字母和下划线组成，所以此题首先应该判断变量名是否是合法的。<br>寻找两种变量的特征，CPP的变量形式是小写字母加下划线组成，两个单词之间只由一个下划线连接，也就是说，aa____bb也是非法变量。JAVA变量则是由大小写字母一起组成，小写字母开头，也就是说X也是非法变量。<br>注意以上几点之后，处理就简单了，CPP转JAVA只需把_x转换成X即可，反之亦然。</p><p>&nbsp;</p><div>#include &lt;stdio.h&gt;</div><div>#include &lt;string.h&gt;</div><div>&nbsp;</div><div>int main()</div><div>{</div><div>&nbsp;&nbsp; &nbsp;char ori[200];</div><div>&nbsp;&nbsp; &nbsp;char res[500];</div><div>&nbsp;&nbsp; &nbsp;bool pdc,pdj;</div><div>&nbsp;&nbsp; &nbsp;while (scanf("%s",ori)!=EOF) {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;pdc=pdj=true;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int len=strlen(ori);</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;for (int i=0;i&lt;len;i++) {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (ori[i]&gt;='A'&amp;&amp;ori[i]&lt;='Z') pdc=false;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (ori[i]=='_') {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pdj=false;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (ori[i+1]==0||ori[i+1]=='_') pdc=pdj=false;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (ori[i]&lt;'a'||ori[i]&gt;'z') pdc=pdj=false;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;if (ori[0]&lt;'a'||ori[0]&gt;'z') pdc=pdj=false;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;memset(res,0,sizeof(res));</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;int curr=1;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;res[0]=ori[0];</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;if (pdc) {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i=1;i&lt;len;i++) {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (ori[i]=='_') continue;</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (ori[i-1]=='_') res[curr++]=ori[i]-'a'+'A';</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else res[curr++]=ori[i];</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (pdj&amp;&amp;strcmp(res,ori)==0) printf("%s\n",res);</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (!pdj) printf("%s\n",res);</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else printf("Unknown!\n");</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;else if (pdj) {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i=1;i&lt;len;i++) {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (ori[i]&gt;='A'&amp;&amp;ori[i]&lt;='Z') {</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res[curr++]='_';</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;res[curr++]=ori[i]-'A'+'a';</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else res[curr++]=ori[i];</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%s\n",res);</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;else printf("Unknown!\n");</div><div>&nbsp;&nbsp; &nbsp;}</div><div>&nbsp;&nbsp; &nbsp;return 0;</div><div>}</div><div>&nbsp;</div><p>&nbsp;</p><p>c<br>观察逆序和交换操作的特点：<br>每次交换操作只可能使逆序+1，-1，或者不变；<br>逆序最小(为0)的时候就是序列从小到大依次排好的；<br>逆序最大的时候就是序列从大到小依次排好的。<br>贪心地做：<br>尽可能大的增加(或者减少)逆序；<br>当序列有序的时候，剩下的操作次数；<br>如果序列有两个数相同，则任意交换相同相邻的数，逆序不变；<br>否则任选两个相邻的数，反复交换，把剩下的次数用完。</p><p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;</p><p>int n,k;<br>int a[2000];</p><p>int main()<br>{<br>&nbsp;&nbsp;&nbsp; while (scanf("%d%d",&amp;n,&amp;k)!=EOF) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum=0,maxp=0,pd=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0;i&lt;n;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j=i+1;j&lt;n;j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[j]&lt;a[i]) sum++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[j]==a[i]) pd=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mind=sum-k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mind&lt;0&amp;&amp;!pd) mind=(-mind)%2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mind&lt;0&amp;&amp;pd) mind=0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int maxd=sum+k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0;i&lt;n;i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j=0;j&lt;n;j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a[j]&lt;a[i]) maxp++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (maxd&gt;maxp&amp;&amp;!pd) maxd=maxp-(maxd-maxp)%2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (maxd&gt;maxp&amp;&amp;pd) maxd=maxp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d %d\n",mind,maxd);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return 0;<br>}</p><p>d<br>本题考查的是同学们的观察能力，ACM题中有些数论题会很明显地告诉你是有规律可找的，这时可以先求出满足题意的前几个数，根据已有的这些数据提出猜想，然后证明或者是简单验证（仅限于比赛）。在本题中，我们通过分解前几组的答案：<br>1&nbsp;&nbsp;&nbsp; =&nbsp; 1&nbsp; × 1<br>6&nbsp;&nbsp;&nbsp; =&nbsp; 2&nbsp; × 3<br>35&nbsp;&nbsp; =&nbsp; 5&nbsp; × 7<br>204&nbsp; =&nbsp; 12 × 17<br>可以在右边的两列数中都推出如下的递推式：<br>P(0)=0<br>P(1)=1<br>P(n)=2*P(n-1)+P(n-2)<br>这个数列被称为是佩尔数，它可以写成如下形式：<br>((P(k+1)+P(k))*P(k))^2=((P(k-1)+P(k))^2*((P(k-1)+P(k))^2-(-1)^k))/2<br>左边是平方数，右边是三角数。<br>不过不知道这些也不会影响对本题的求解。另外，单纯地枚举过不了此题，但通过转化公式来提高枚举的效率，也同样是可行的。 其实，还有一种方法是事先在电脑上打印出所有解（因为题目规定了解的范围），把解存下后根据输入输出相应的答案，俗称打表。</p><p>#include &lt;stdio.h&gt;<br>int main()<br>{<br>&nbsp;&nbsp; int T, k, i, x1, x2;<br>&nbsp;&nbsp; scanf("%d", &amp;T);<br>&nbsp;&nbsp; while(T--) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d", &amp;k);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x1 = 1, x2 = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 1; i &lt; k; ++i) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x2 = 2 * x1 + x2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x1 = x2 - x1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d\n", x1 * x2);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; return 0;<br>}</p><p><br>e<br>物理题<br>题意较简单，正n边形上每个人的瞬时速度指向他前面的一个人，因此只需要对前一个人的速度进行分解，即可得到两个人的相对速度。<br>将速度v分解成指向中心的分量v1以及与它垂直的另一个分量v2，v2可以看作是导致运动方向旋转的速度，所以不影响时间。<br>再利用t=s0/v1，就可以得到答案，其中s0是顶点到中心的长度（半径），最后路程s=v*t。</p><p>#include&lt;stdio.h&gt;<br>#include&lt;math.h&gt;<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; int n;<br>&nbsp;&nbsp;&nbsp; double r,l,v,pi=acos(-1.0),t,s;<br>&nbsp;&nbsp;&nbsp; while(scanf("%d%lf%lf",&amp;n,&amp;l,&amp;v)!=EOF)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r=l/2/sin(pi/n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t=r/(v*sin(pi/n));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s=t*v;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%.4lf %.4lf\n",t,s);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return 0;<br>}</p><p>化简后直接结论：<br>#include&lt;stdio.h&gt;<br>#include&lt;math.h&gt;<br>const double pi=acos(-1.0);<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; int n;<br>&nbsp;&nbsp;&nbsp; double l,v,t,vnew;<br>&nbsp;&nbsp;&nbsp; while(scanf("%d%lf%lf",&amp;n,&amp;l,&amp;v)!=EOF)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t=2*pi/n;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vnew=v-v*cos(t);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%.4f %.4f\n",l/vnew,l*v/vnew);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; return 0;<br>}</p></span><wbr>
